✍🏻 [2022.05.25.Wed]

## **✅ 1장. 컴퓨터 내부의 언어 체계**

### 📎 비트

> - binary(2진법 사용; 0,1) + digit(숫자; 10진수: 0~9)

- 비트를 사용하면 적은 비용으로 편리하게 기호를 담을 수 있다
- 비트는 2진법 사용
  >

> 논리 연산(logic operation)
> : 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작

### 📎 불리언 대수(Boolean algebra)

> 비트에 대해 사용할 수 있는 연산 규칙의 집합

- NOT: 논리적 반대 / 단지 입력의 상태를 반대로 반전
- AND: 둘 이상의 비트에 작용 / 모두 참이어야 참
- OR: 둘 이상의 비트에 작용 / 어느 하나라도 참이면 참
- XOR(eXclusive OR): 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참

### 📎 드모르간의 법칙

> a AND b 연산 = NOT(NOT a OR NOT b) <br/>
> ⇒ NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신할 수 있다(역도 성립) <br/>
> 👍 연산을 최소화하여 비용을 최소화할 수 있음

### 📎 정수를 비트로 표현하는 방법

1.  **양의 정수 표현**

    ex. 2진수로 표현한 5,028 → 13비트 수

    | 2^12 | 2^11 | 2^10 | 2^9 | 2^8 | 2^7 | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
    | ---- | ---- | ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    | 1    | 0    | 0    | 1   | 1   | 1   | 0   | 1   | 0   | 0   | 1   | 0   | 0   |
    | MSB  |      |      |     |     |     |     |     |     |     |     |     | LSB |

    ✋ MSB: Most Significant Bit

    ✋ LSB: Least Significant Bit

2.  **2진수의 덧셈**

    ex. 1 + 5

    | [1] | 0   | 0   | 1   |
    | --- | --- | --- | --- |
    | [5] | 1   | 0   | 1   |
    | [6] | 1   | 1   | 0   |

    ✋ 1 + 1 → 2 (2진수에서 2는 존재하지않으므로 2를 2진수로 나타내면 10 → 즉 0을 표시하고 다음 자리 수에 1을 올려줌

    ✋ `Overflow`: 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어날 경우 발생 ⇒ MSB에서 올림 발생

    ✋ `Underflow`: MSB 위쪽에서 1을 빌려오는 경우

3.  **음수 표현** <br/>

    **a. 부호와 크기(sign and magnitude) 표현법**

    - MSB를 부호 표현 (0: 양수, 1: 음수 취급)
    - 만약 4비트라면 MSB를 부호 비트 취급을 하고 나면 0~7→ 8개 \* 2(음수, 양수) → 16개 - 1(+0 = -0) = 총 15가지의 수 표현 가능

      ✋ 0을 표현하는 방법이 2가지(+0, -0)이므로 비용 낭비, XOR & AND 덧셈 계산 사용 불가 → 사용 X

    **b. 1의 보수(one’s complement) 표현법**

    - 양수의 모든 비트를 뒤집는 방법
    - MSB 쪽에서 올림이 발생한 경우 LSB로 올림 전달 ⇒ `순환 올림`(end-around carry) 필요

    ![F38CB06A-4623-4AB9-A598-4BB3EEAB3AEF](https://user-images.githubusercontent.com/64299610/170288978-e9d0bd02-97fd-46fd-8359-d67dd05d1750.jpeg)

    ✋ 0을 표현하는 방법이 2가지(+0, -0)이므로 비용 낭비, 순환 올림 방법 복잡 → 사용 X

    **c. 2의 보수(two’s complement) 표현법**

    - 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법
    - 예를 들어 +1(0001)과 더해 0(0000)을 만들 수 있는 수인 -1의 2진법 수 찾기
      ![3B93D204-4AF8-4C76-BE50-B4DEEF8ABEAF](https://user-images.githubusercontent.com/64299610/170288986-93511928-f9fc-4a0f-be1c-0cc53a009d4e.jpeg)

    → 즉, -1을 2진법 1111로 표현
    ⇒ 어떤 수의 비트를 뒤집고(NOT) 1을 추가하면 어떤 수의 음수 표현 가능

    ✋ 이때 MSB에서 올림이 발생하면 이 값은 버림

    👍 0의 중복 표현이 일어나지 않음
